---
title: "Akka http"
subtitle: "「Akka http官方文档」- 2.6.8"
layout: post
author: "LiuL"
header-style: text
tags:
  - Akka
  - Akka http
---

# 1. Maven依赖

当前akka最新版本2.6.8、akka http最新版本为10.2.0


```xml
    <properties>
        <akka.version>2.6.8</akka.version>
        <akka.http.version>10.2.0</akka.http.version>
        <scala.binary.version>2.13</scala.binary.version>
        <lombok.version>1.18.12</lombok.version>
        <logback.version>1.2.3</logback.version>
        <junit.version>4.12</junit.version>
    </properties>

    <dependencies>
        <!-- akka stream -->
        <dependency>
            <groupId>com.typesafe.akka</groupId>
            <artifactId>akka-stream_${scala.binary.version}</artifactId>
            <version>${akka.version}</version>
        </dependency>
        <!-- akka http -->
        <dependency>
            <groupId>com.typesafe.akka</groupId>
            <artifactId>akka-http_${scala.binary.version}</artifactId>
            <version>${akka.http.version}</version>
        </dependency>
        <dependency>
            <groupId>com.typesafe.akka</groupId>
            <artifactId>akka-http-core_${scala.binary.version}</artifactId>
            <version>${akka.http.version}</version>
        </dependency>
        <!-- akka http jackson-->
        <dependency>
            <groupId>com.typesafe.akka</groupId>
            <artifactId>akka-http-jackson_${scala.binary.version}</artifactId>
            <version>${akka.http.version}</version>
        </dependency>
        <!-- akka http test-->
        <dependency>
            <groupId>com.typesafe.akka</groupId>
            <artifactId>akka-http-testkit_${scala.binary.version}</artifactId>
            <version>${akka.http.version}</version>
        </dependency>
    </dependencies>
```

# 2. Akka http简介

Akka HTTP的高级路由API提供了一个DSL，用于描述HTTP “路由” 以及如何处理它们, 每个路由由一个或多个级别组成，范围缩小到处理一种特定类型的请求。

 例如
- 一条路由可能以匹配path请求的开头，只有在请求地址匹配“/hello”时才匹配，
- 然后将其范围缩小为仅处理HTTP get请求
- 然后将其处理为complete带有字符串文字的请求，这些请求将以HTTP OK的形式发送回字符串作为响应主体
- 然后，使用Route路由DSL创建的内容被“绑定”到端口以开始服务HTTP请求

> **注意**
> 自定义HTTP路由类记得继承AllDirectives
> > AllDirectives ： 将所有默认指令收集到一个类中，以便简单地导入静态函数。
> > JavaDSL See [[akka.http.javadsl.server.AllDirectives]]
> > ScalaDSLSee [[akka.http.scaladsl.server.Directives]]

如下：
```java
public class HttpServerMinimal extends AllDirectives
```

# 3. Hello Akka HTTP

第一个最小级别入门示例Hello Akka Http

## 3.1. 说明

使用Akka 构建本地localhost:8080的Http路由，添加请求地址/hello, 将处理为消息Complete带有字符串文字的请求,请求将以HTTP OK的形式发送回字符串作为响应主体。

即为绑定`http://localhost:8080`的get请求，请求路径添加“/hello”响应主体`complete("<h1>Say hello to akka-http</h1>"))`, 最终响应体为`<h1>Say hello to akka-http</h1>"`

## 3.2. akka配置

resource创建文件http_test.conf并添加如下内容：

```conf
akka {
  loggers = ["akka.event.slf4j.Slf4jLogger"]
  loglevel = debug
  actor {
    provider = cluster
    allow-java-serialization = off
  }
  remote {
    artery {
      # transport = tcp
      canonical.hostname = "127.0.0.1"
      canonical.port = 25520
    }
  }
   cluster {
      # seed-nodes = [
       # "akka://ClusterSystem@127.0.0.1:25251",
       # "akka://ClusterSystem@127.0.0.1:25252"]
      downing-provider-class = "akka.cluster.sbr.SplitBrainResolverProvider"
    }
}
```

## 3.3. 路由Route代码

通过concat方法path创建`/hello`路由并且绑定get请求，将其处理为complete带有字符串文字的请求，这些请求将以HTTP OK的形式发送回字符串作为响应主体。

```java
 private Route createRoute() {
        return concat(
                path("hello", () ->
                        get(() ->
                                complete("<h1>Say hello to akka-http</h1>"))));
    }
```

## 3.4. 创建Actor System

```java
//自定义配置
Map<String, Object> overrides = new HashMap<>();
//可选的，如果不配置则默认端口为27700
overrides.put("akka.remote.artery.canonical.port", "27702");
//overrides.put("akka.cluster.roles", Collections.singletonList(role));
    //使用覆盖的配置加上http_test.conf
Config config = ConfigFactory.parseMap(overrides).withFallback(ConfigFactory.load("http_test"));
//创建空类型ActorySystem
ActorSystem<Void> system = ActorSystem.create(Behaviors.empty(), "routes", config);
```

## 3.5. 通过Actor System创建Http

```java
final Http http = Http.get(system);
```

## 3.6. 创建路由

通过应用实例调用上面的[createRoute](#创建路由)创建路由方法创建路由。

```java
Route route = new HttpServerMinimal().createRoute();
```

## 3.7. http构建Server绑定ip和端口

```java
 final CompletionStage<ServerBinding> binding =
                http.newServerAt("localhost", 8080)
                        .bind(route);
```

## 3.8. 根据实际情况清除绑定和停止Actor System

```java
//从端口解除绑定的触发器,解除后停止ActorSystem
binding.thenCompose(ServerBinding::unbind).thenAccept(unbound -> system.terminate()); 
```

## 3.9. 完整示例代码

```java
package com.tcfuture.akka.http.minisample;

import akka.actor.typed.ActorSystem;
import akka.actor.typed.javadsl.Behaviors;
import akka.http.javadsl.Http;
import akka.http.javadsl.ServerBinding;
import akka.http.javadsl.server.AllDirectives;
import akka.http.javadsl.server.Route;
import com.typesafe.config.Config;
import com.typesafe.config.ConfigFactory;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.CompletionStage;

/**
 * 最小入门示例 Hello Akka Http
 *
 * @author liulv
 * @since 1.0.0
 */
public class HttpServerMinimal extends AllDirectives {

    public static void main(String[] args) throws Exception {
        //自定义配置
        Map<String, Object> overrides = new HashMap<>();
        //可选的，如果不配置则默认端口为27700
        overrides.put("akka.remote.artery.canonical.port", "27702");
        //overrides.put("akka.cluster.roles", Collections.singletonList(role));
         //使用覆盖的配置加上http_test.conf
        Config config = ConfigFactory.parseMap(overrides).withFallback(ConfigFactory.load("http_test"));
        //创建空类型ActorySystem
        ActorSystem<Void> system = ActorSystem.create(Behaviors.empty(), "routes", config);

        final Http http = Http.get(system);

        //创建路由
        Route route = new HttpServerMinimal().createRoute();

        final CompletionStage<ServerBinding> binding =
                http.newServerAt("localhost", 8080)
                        .bind(route);

        System.out.println("Server online at http://localhost:8080/\nPress RETURN to stop...");
        System.in.read(); // let it run until user presses return

        binding.thenCompose(ServerBinding::unbind) //从端口解除绑定的触发器
                .thenAccept(unbound -> system.terminate()); // 完成后关闭
    }

    private Route createRoute() {
        return concat(
                path("hello", () ->
                        get(() ->
                                complete("<h1>Say hello to akka-http</h1>"))));
    }
}
```

## 3.10. 示例测试

1. 运行main方法即可启动Akka Http。

![20200914114137](https://liulv.work/images/img/20200914114137.png)

2. 通过http get请求/hello,请求响应为`<h1>Say hello to akka-http</h1>`

> * a. http get请求可通过浏览器请求`http://localhost:8080/hello`测试，如下

![20200914113900](https://liulv.work/images/img/20200914113900.png)

请求响应如下：

![20200914114430](https://liulv.work/images/img/20200914114430.png)

> * 通过curl 测试，git bash 或 shell输入`curl http://localhost:8080/hello`

![20200914114743](https://liulv.work/images/img/20200914114743.png)

# 4. Jackson Example

## 4.1. 示例简介

 一个常见的用例是使用模型对象来答复请求，该模型对象将编组器将其转换为JSON。在这种情况下，显示为两条单独的路线。
* 第一条路由查询异步数据库，并将结果编组为JSON响应。
* 第二个从收到的请求中解组一个an ，将其保存到数据库中，并在完成后单击OK进行回复。CompletionStage<Optional<Item>>Order

运行此服务器时，可以通过 curl http://localhost:8080/create-order -H "Content-Type: application/json" -X POST -d '{"items":[{"name":"hhgtg","id":42}]}'
终端上的库存更新-添加名为"hhgtg"并具有的项目id=42。

然后在浏览器中通过类似http://localhost:8080/item/42的URL 或在终端上通过来查看清单curl http://localhost:8080/item/42。

在本示例中，用于编组和解组JSON的逻辑由“Jackson”库提供。见JSON支持），以获取有关该库集成的详细信息, 需要添加akka-http-jackson的maven依赖。

```xml
 <!-- akka http jackson-->
<dependency>
    <groupId>com.typesafe.akka</groupId>
    <artifactId>akka-http-jackson_${scala.binary.version}</artifactId>
    <version>${akka.http.version}</version>
</dependency>
```

**特别说明**

onSuccess 参数使用异步编程方式CompletionStage， f(completionStage.v) =  ... complete(respons_body) )

创建CompletionStage方式，这里使用CompletableFuture.completedFuture(...)

如果没有完成值可使用下面方式：
```java
CompletableFuture.completedFuture(Done.getInstance());
```
Done通常与“Future未来”一起使用以表示完成，但没有完成的实际值。更清楚地表明意图比`Unit`，并且在Scala和Java中都可用（而`Unit`不是）。


## 4.2. 创建路由

编组和解析json使用如下方式
```java
  path("..pathName", () -> entity(Jackson.unmarshaller(Order.class), order ->
CompletionStage completionStage = ..
returu onSuccess(completionStage, evn - > .. complete(body))
```

示例创建路由
 * post请求"create-order"，解析实体的json字符串请求参数转换为Order, 调用保存order的逻辑，返回CompletionStage， 保存完成后onSuccess响应complete的响应体。
 * get请求，路径前缀`/item`, 路径添加`/id值`,查询库查询到结果返回CompletionStage<Optional<Item>>，onSuccess响应如果存在值响应每个item, 否则orElseGet响应StatusCodes.NOT_FOUND，响应体"Not Found"字符
 * 

```java
private Route createRoute() {
        return concat(
                get(() ->
                        pathPrefix("item", () ->
                                path(longSegment(), (Long id) -> {
                                    final CompletionStage<Optional<Item>> futureMaybeItem = fetchItem(id);
                                    return onSuccess(futureMaybeItem, maybeItem ->
                                            maybeItem.map(item -> completeOK(item, Jackson.marshaller()))
                                                    .orElseGet(() -> complete(StatusCodes.NOT_FOUND, "Not Found"))
                                    );
                                }))),
                post(() ->
                        path("create-order", () ->
                                entity(Jackson.unmarshaller(Order.class), order -> {
                                    CompletionStage<Done> futureSaved = saveOrder(order);
                                    return onSuccess(futureSaved, done ->
                                            complete("order created")
                                    );
                                })))
        );
    }
```

## 4.3. 创建ActorSystem、http并绑定端口和路由

```java
        Map<String, Object> overrides = new HashMap<>();
        overrides.put("akka.remote.artery.canonical.port", "27701");
        //overrides.put("akka.cluster.roles", Collections.singletonList(role));
        Config config = ConfigFactory.parseMap(overrides)
                .withFallback(ConfigFactory.load("http_test"));
        ActorSystem<Void> system = ActorSystem.create(Behaviors.empty(), "routes", config);

        final Http http = Http.get(system);

        //In order to access all directives we need an instance where the routes are define.
        JacksonExample app = new JacksonExample();

        final CompletionStage<ServerBinding> binding =
                http.newServerAt("localhost", 8080)
                        .bind(app.createRoute());
```

## 4.4. 路由使用查询数据和保存数据

创建POJ, 注意这里需要解析json字符，构造方法需要使用@JsonCreator

```java
    @Getter
    private static class Order {

        final List<Item> items;

        @JsonCreator
        Order(@JsonProperty("items") List<Item> items) {
            this.items = items;
        }
    }


    @Getter
    private static class Item {

        final String name;
        final long id;

        @JsonCreator
        Item(@JsonProperty("name") String name,
             @JsonProperty("id") long id) {
            this.name = name;
            this.id = id;
        }
    }
```

这里模拟查询数据如下：

```java
private CompletionStage<Optional<Item>> fetchItem(long itemId) {
        return CompletableFuture.completedFuture(Optional.of(new Item("foo", itemId)));
    }
```

模拟保存数据

```java
// (fake) async database query api
    private CompletionStage<Done> saveOrder(final Order order) {
        return CompletableFuture.completedFuture(Done.getInstance());
    }
```

## 4.5. 完成代码

```java
package com.tcfuture.akka.http.jsonsample;

import akka.Done;
import akka.actor.typed.ActorSystem;
import akka.actor.typed.javadsl.Behaviors;
import akka.http.javadsl.Http;
import akka.http.javadsl.ServerBinding;
import akka.http.javadsl.marshallers.jackson.Jackson;
import akka.http.javadsl.model.StatusCodes;
import akka.http.javadsl.server.AllDirectives;
import akka.http.javadsl.server.Route;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.typesafe.config.Config;
import com.typesafe.config.ConfigFactory;
import lombok.Getter;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionStage;

import static akka.http.javadsl.server.PathMatchers.longSegment;

/**
 * @author liulv
 *
 * 一个常见的用例是使用模型对象来答复请求，该模型对象将编组器将其转换为JSON。在这种情况下，显示为两条单独的路线。
 * 第一条路由查询异步数据库，并将结果编组为JSON响应。第二个从收到的请求中解组一个an ，将其保存到数据库中，并在
 * 完成后单击OK进行回复。CompletionStage<Optional<Item>>Order
 *
 * 运行此服务器时，可以通过 curl http://localhost:8080/create-order -H "Content-Type: application/json" -X POST -d '{"items":[{"name":"hhgtg","id":42}]}'
 * 终端上的库存更新-添加名为"hhgtg"并具有的项目id=42。然后在浏览器中通过类似http://localhost:8080/item/42
 * 的URL 或在终端上通过来查看清单curl http://localhost:8080/item/42。
 *
 * 在本示例中，用于编组和解组JSON的逻辑由“ Jackson”库提供。见JSON支持），以获取有关该库集成的详细信息
 */
public class JacksonExample extends AllDirectives {

    public static void main(String[] args) throws Exception {
        // boot up server using the route as defined below
        Map<String, Object> overrides = new HashMap<>();
        overrides.put("akka.remote.artery.canonical.port", "27701");
        //overrides.put("akka.cluster.roles", Collections.singletonList(role));
        Config config = ConfigFactory.parseMap(overrides)
                .withFallback(ConfigFactory.load("http_test"));
        ActorSystem<Void> system = ActorSystem.create(Behaviors.empty(), "routes", config);

        final Http http = Http.get(system);

        //In order to access all directives we need an instance where the routes are define.
        JacksonExample app = new JacksonExample();

        final CompletionStage<ServerBinding> binding =
                http.newServerAt("localhost", 8080)
                        .bind(app.createRoute());

        System.out.println("Server online at http://localhost:8080/\nPress RETURN to stop...");
        System.in.read(); // let it run until user presses return

        binding
                .thenCompose(ServerBinding::unbind) // trigger unbinding from the port
                .thenAccept(unbound -> system.terminate()); // and shutdown when done
    }

    // (fake) async database query api
    private CompletionStage<Optional<Item>> fetchItem(long itemId) {
        return CompletableFuture.completedFuture(Optional.of(new Item("foo", itemId)));
    }

    // (fake) async database query api
    private CompletionStage<Done> saveOrder(final Order order) {
        return CompletableFuture.completedFuture(Done.getInstance());
    }

    private Route createRoute() {
        return concat(
                get(() ->
                        pathPrefix("item", () ->
                                path(longSegment(), (Long id) -> {
                                    final CompletionStage<Optional<Item>> futureMaybeItem = fetchItem(id);
                                    return onSuccess(futureMaybeItem, maybeItem ->
                                            maybeItem.map(item -> completeOK(item, Jackson.marshaller()))
                                                    .orElseGet(() -> complete(StatusCodes.NOT_FOUND, "Not Found"))
                                    );
                                }))),
                post(() ->
                        path("create-order", () ->
                                entity(Jackson.unmarshaller(Order.class), order -> {
                                    CompletionStage<Done> futureSaved = saveOrder(order);
                                    return onSuccess(futureSaved, done ->
                                            complete("order created")
                                    );
                                })))
        );
    }

    @Getter
    private static class Item {

        final String name;
        final long id;

        @JsonCreator
        Item(@JsonProperty("name") String name,
             @JsonProperty("id") long id) {
            this.name = name;
            this.id = id;
        }
    }

    @Getter
    private static class Order {

        final List<Item> items;

        @JsonCreator
        Order(@JsonProperty("items") List<Item> items) {
            this.items = items;
        }
    }
}
```


## 4.6. 测试

运行

![20200914140822](https://liulv.work/images/img/20200914140822.png)


运行此服务器后，可以通过 curl http://localhost:8080/create-order -H "Content-Type: application/json" -X POST -d '{"items":[{"name":"hhgtg","id":42}]}'
终端上的库存更新-添加名为"hhgtg"并具有的项目id=42, 如下图

![20200914141043](https://liulv.work/images/img/20200914141043.png)

然后在浏览器中通过类似http://localhost:8080/item/42的URL 或在终端上通过来查看清单curl http://localhost:8080/item/42。

curl测试如下：

![20200914141238](https://liulv.work/images/img/20200914141238.png)

浏览器请求：

![20200914141431](https://liulv.work/images/img/20200914141431.png)

# 5. Streaming 

Akka HTTP的优势之一是流数据是其核心，这意味着请求和响应主体都可以通过服务器进行流传输，即使对于非常大的请求或响应，也可以实现恒定的内存使用率。流响应将由远程客户端施加压力，因此服务器将不会以比客户端可以处理的速度更快地推送数据，流请求意味着服务器决定远程客户端可以以多快的速度推送请求主体的数据。

只要客户端接受随机流的示例：

```java
private Route createRoute(){
        //随机数
        final Random rnd = new Random();
        // 流是可重用的，所以我们可以在这里定义它
        // 并对每个请求使用它
        Source<Integer, NotUsed> numbers = Source.fromIterator(() -> Stream.generate(rnd::nextInt).iterator());

        return concat(path("random", () ->
                get(() ->
                        complete(HttpEntities.create(ContentTypes.TEXT_PLAIN_UTF8,
                                //将每个数字转换为字节块
                                numbers.map(x -> ByteString.fromString(x + "\n"))
                                ))
                        )
        ));
    }
```

使用慢速的HTTP客户端连接到该服务将产生反压力，以便根据需要在服务器上保持不变的内存使用情况下生成下一个随机数。使用卷曲和限制速率可以看出这一点curl --limit-rate 50b 127.0.0.1:8080/random


# 6. Http与Actor交互

这个是我们的核心内容，我们通过发布http，最终通过ask请求act获取response，返回HTTP OK 或 KO的响应体，来达到不同Akka 集群之间actor消息交互效果。

## 6.1. 示例1-Auction

### 6.1.1. 示例说明

Akka HTTP路由可以轻松地与参与者进行交互。在此示例中，一条路线允许以即发即弃(actor.tell)的方式发送出价竞标，而第二条路线包含与演员的请求-响应交互，结果响应将呈现为json，并在响应从actor到达时返回。

此示例是模拟一个拍卖竞标信息，需要构建一个内部类拍卖类Auction用于构建Actor, Actor之间交互的信息POJO包含: 竞标者信息Bid（用户ID和中标数offer）、获取竞标信息GetBids（ActorRef<Bids>）、存储拍卖信息Bids（list<Bid>）。
还需要添加Actor实例存储拍卖信息的参数List<Bid> bids;

### 6.1.2. Actor处理

**为此给出内部拍卖信息Actor对象如下, 不使用内部类也可以**

```java
static class Auction extends AbstractBehavior<Auction.Message> {

    //竞标列表
    private List<Bid> bids = new ArrayList<>();

    interface Message {}

    //竞标者信息
    @AllArgsConstructor
    @Getting
    static class Bid implements Message {
        final String userId;
        final int offer;
    }

    //获取竞标信息
    @AllArgsConstructor
    static class GetBids implements Message {
        final ActorRef<Bids> replyTo;
    }

    //全部竞标信息
    @AllArgsConstructor
    static class Bids {
        public final List<Bid> bids;
    }

    public Auction(ActorContext<Message> context) {
        super(context);
    }

    public static Behavior<Message> create() {
        return Behaviors.setup(Auction::new);
    }

    @Override
    public Receive<Message> createReceive() {
        return newReceiveBuilder()
                .onMessage(Bid.class, this::onBid)
                .onMessage(GetBids.class, this::onGetBids)
                .build();
    }

    /**
        * 开始竞标消息回复，将竞标信息添加到竞标集合中
        *
        * @param bid Bid
        * @return
        */
    private Behavior<Message> onBid(Bid bid) {
        bids.add(bid);
        getContext().getLog().info("Bid complete: {}, {}", bid.userId, bid.offer);
        return this;
    }

    /**
        * 获取当前全部的竞标信息
        *
        * @param getBids GetBids
        * @return Bids-示例中存储的竞标集合构建Bids实例返回
        */
    private Behavior<Message> onGetBids(GetBids getBids) {
        getBids.replyTo.tell(new Bids(bids));
        return this;
    }
}
```

### 6.1.3. 创建Route

Route主要有两种情况处理：添加竞标信息、获取当前拍卖信息，分别对应Actor消息处理Auction.Bid、Auction.GetBids。
* 添加竞标信息只是即发即弃tell方式，不需要返回值
* 而获取当前拍卖信息需要获取actor响应，使用ask方法，使用异步处理CompletionStage<Auction.Bids>， 使用completeOKWithFuture(bids, Jackson.marshaller())返回POJO转换为JSON数据响应。


```java
 private Route createRoute() {
    return concat(
            path("auction", () -> concat(
                    put(() ->
                            parameter(StringUnmarshallers.INTEGER, "bid", bid ->
                                    parameter("user", user -> {
                                        //竞标，发完即丢弃，不用等待响应
                                        auction.tell(new Auction.Bid(user, bid));
                                        return complete(StatusCodes.ACCEPTED, "bid placed");
                                    })
                            )),
                    get(() -> {
                        //向actor查询当前拍卖状态
                        CompletionStage<Auction.Bids> bids = ask(auction, Auction.GetBids::new, Duration.ofSeconds(5), system.scheduler());
                        return completeOKWithFuture(bids, Jackson.marshaller());
                    }))));
}
```

### 6.1.4. 完整示例代码

```java
package com.tcfuture.akka.http.interaction;

import akka.actor.typed.ActorRef;
import akka.actor.typed.ActorSystem;
import akka.actor.typed.Behavior;
import akka.actor.typed.javadsl.AbstractBehavior;
import akka.actor.typed.javadsl.ActorContext;
import akka.actor.typed.javadsl.Behaviors;
import akka.actor.typed.javadsl.Receive;
import akka.http.javadsl.Http;
import akka.http.javadsl.ServerBinding;
import akka.http.javadsl.marshallers.jackson.Jackson;
import akka.http.javadsl.model.StatusCodes;
import akka.http.javadsl.server.AllDirectives;
import akka.http.javadsl.server.Route;
import akka.http.javadsl.unmarshalling.StringUnmarshallers;
import com.typesafe.config.Config;
import com.typesafe.config.ConfigFactory;
import lombok.AllArgsConstructor;

import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.CompletionStage;

import static akka.actor.typed.javadsl.AskPattern.ask;

/**
 * Akka HTTP路由可以轻松地与Actor进行交互。在此示例中，一条路线允许以即发即弃的方式放置出价，而第二条路线包含
 * 与actor的请求-响应交互。结果响应将呈现为json，并在响应从actor到达时返回。
 *
 * @author liulv
 * @since 1.0.0
 */
public class HttpServerActorInteractionExample extends AllDirectives {

    //ActorSystem属性
    private final ActorSystem<Auction.Message> system;
    //ActorRef 拍卖
    private final ActorRef<Auction.Message> auction;

    public static void main(String[] args) throws Exception {
        Config config = ConfigFactory.load("http_test");
        // boot up server using the route as defined below
        ActorSystem<Auction.Message> system = ActorSystem.create(Auction.create(), "routes", config);

        final Http http = Http.get(system);

        //In order to access all directives we need an instance where the routes are define.
        HttpServerActorInteractionExample app = new HttpServerActorInteractionExample(system);

        final CompletionStage<ServerBinding> binding =
                http.newServerAt("localhost", 8080)
                        .bind(app.createRoute());

        System.out.println("Server online at http://localhost:8080/\nPress RETURN to stop...");
        System.in.read(); // let it run until user presses return

        binding
                .thenCompose(ServerBinding::unbind) // trigger unbinding from the port
                .thenAccept(unbound -> system.terminate()); // and shutdown when done
    }

    private HttpServerActorInteractionExample(final ActorSystem<Auction.Message> system) {
        this.system = system;
        this.auction = system;
    }

    private Route createRoute() {
        return concat(
                path("auction", () -> concat(
                        put(() ->
                                parameter(StringUnmarshallers.INTEGER, "bid", bid ->
                                        parameter("user", user -> {
                                            //竞标，发完即丢弃，不用等待响应
                                            auction.tell(new Auction.Bid(user, bid));
                                            return complete(StatusCodes.ACCEPTED, "bid placed");
                                        })
                                )),
                        get(() -> {
                            //向actor查询当前拍卖状态
                            CompletionStage<Auction.Bids> bids = ask(auction, Auction.GetBids::new, Duration.ofSeconds(5), system.scheduler());
                            return completeOKWithFuture(bids, Jackson.marshaller());
                        }))));
    }

    static class Auction extends AbstractBehavior<Auction.Message> {

        //竞标列表
        private List<Bid> bids = new ArrayList<>();

        interface Message {}

        //竞标者信息
        @AllArgsConstructor
        @Getter
        static class Bid implements Message {
            final String userId;
            final int offer;
        }

        //获取竞标信息
        @AllArgsConstructor
        static class GetBids implements Message {
            final ActorRef<Bids> replyTo;
        }

        //全部竞标信息
        @AllArgsConstructor
        static class Bids {
            public final List<Bid> bids;
        }

        public Auction(ActorContext<Message> context) {
            super(context);
        }

        public static Behavior<Message> create() {
            return Behaviors.setup(Auction::new);
        }

        @Override
        public Receive<Message> createReceive() {
            return newReceiveBuilder()
                    .onMessage(Bid.class, this::onBid)
                    .onMessage(GetBids.class, this::onGetBids)
                    .build();
        }

        /**
         * 开始竞标消息回复，将竞标信息添加到竞标集合中
         *
         * @param bid Bid
         * @return
         */
        private Behavior<Message> onBid(Bid bid) {
            bids.add(bid);
            getContext().getLog().info("Bid complete: {}, {}", bid.userId, bid.offer);
            return this;
        }

        /**
         * 获取当前全部的竞标信息
         *
         * @param getBids GetBids
         * @return Bids-示例中存储的竞标集合构建Bids实例返回
         */
        private Behavior<Message> onGetBids(GetBids getBids) {
            getBids.replyTo.tell(new Bids(bids));
            return this;
        }
    }
}

```

### 6.1.5. 运行测试

**运行main方法进行测试**

运行如下图：

![20200914162930](https://liulv.work/images/img/20200914162930.png)


**添加拍卖出价（竞标信息）测试**

可以curl -X PUT "http://localhost:8080/auction?bid=22&user=MartinO"在终端上通过添加拍卖出价(竞标信息)。

![20200914163223](https://liulv.work/images/img/20200914163223.png)

**查看拍卖信息（全部的竞标信息）测试**

然后您可以在浏览器中，URL http//localhost:8080/auction上或在终端上通过来查看拍卖状态curl http://localhost:8080/auction。

![20200915103120](https://liulv.work/images/img/20200915103120.png)

![20200915103210](https://liulv.work/images/img/20200915103210.png)

**遇到BUG：将Bis POJO解析json报错无法解析其中属性List<Big>，提示无法系列化Big POJO类**

Big POJO要作为Bids中list集合属性, 需要添加@Getter, 不然会无法解析Bids中的Bid集合, 报错无法系列化Big类。

![20200915103653](https://liulv.work/images/img/20200915103653.png)

**有关JSON编组和解编**

有关JSON编组和解编工作方式的更多详细信息，请参见[JSON支持](https://doc.akka.io/docs/akka-http/current/common/json-support.html)部分。

在“高级服务器端API”小节中了解有关高级API的详细信息。

## 6.2. 示例2-Job操作

### 6.2.1. 示例简介

我们将创建一个小型Web服务器（Job作业管理），该服务器负责内容有以下3方面内容：
1. 记录其状态和持续时间的构建作业Job
2. 按ID和状态查询作业
3. 清除作业Job历史记录。

### 6.2.2. 构建Job信息的存储库-与实际Actor交互

构建Actor-JobRepository，Actor交互必不可少必须先添加消息交付需要的POJO.

**Job POJO**

这里首先需要定义Job POJO，包含主键ID、项目名称、状态、持续时间等属性，并添加Jackson编组和解组JSON支持的配置@JsonFormat、 @JsonProperty、@JsonCreator等注解。Json参数模式使用JsonCreator.Mode.PROPERTIES即指示创建者的参数将不受匹配约束，使用创建者参数名称（显式或隐式）的传入对象值的属性使传入的 Object属性与参数匹配。
```java
   /**
     * Job json对象
     */
    @AllArgsConstructor
    @JsonFormat
    @ToString
    public static final class Job {
        @JsonProperty("id")
        final Long id;
        @JsonProperty("project-name")
        final String projectName;
        @JsonProperty("status")
        final String status;
        @JsonProperty("duration")
        final Long duration;

        @JsonCreator(mode = JsonCreator.Mode.PROPERTIES)
        public Job(@JsonProperty("id") Long id, @JsonProperty("project-name") String projectName,
                   @JsonProperty("duration") Long duration) {
            this(id, projectName, "Success", duration);
        }
    }
```

**Actor消息类型Actor请求成功或失败的响应-Response**

```java
  // 成功和失败响应
    interface Response {}

    /**
     * 成功响应OK
     */
    public static final class OK implements Response {
        private static OK INSTANCE = new OK();

        private OK() {}

        public static OK getInstance() {
            return INSTANCE;
        }
    }

    /**
     * 失败响应
     */
    @AllArgsConstructor
    public static final class KO implements Response {
        //失败原因
        final String reason;
    }
```

**Actor行为类型**

```java
    //可以发送到此行为的所有可能的消息接口, 此actor需要接收的消息都必须继承Command接口
    interface Command {}

     /**
     * 添加job
     */
    @AllArgsConstructor
    public static final class AddJob implements Command {
        final Job job;
        final ActorRef<Response> replyTo;
    }

    /**
     * 根据job ID获取Job信息
     */
    @AllArgsConstructor
    public static final class GetJobById implements Command {
        final Long id;
        final ActorRef<Optional<Job>> replyTo;
    }

    /**
     * 创建job 实例
     */
    @AllArgsConstructor
    public static final class ClearJobs implements Command {
        final ActorRef<Response> replyTo;
    }
```

**Actor实例-AbstractBehavior**

上面已经创建消息交互相关的消息POJO和响应POJO, 那么接下来需要创建抽象行为AbstractBehavior创建Actor并接收处理AddJob、GetJobById、ClearJobs消息。

```java
public class JobRepository extends AbstractBehavior<JobRepository.Command> {

    /**
     * jobs属性，添加所有添加job信息: Map<jobId, Job>
     */
    private Map<Long, Job> jobs;

    /**
     * 创建 Behavior
     * @return Behavior<Command>
     */
    public static Behavior<Command> create() {
        return create(new HashMap<Long, Job>());
    }

     /**
     * 创建Behavior 方法
     * @param jobs Map<Long, Job>
     * @return Behavior<Command>
     */
    public static Behavior<Command> create(Map<Long, Job> jobs) {
        return Behaviors.setup(context -> new JobRepository(context, jobs));
    }

    /**
     * Actor 构造函数
     *
     * @param context ActorContext<Command>
     * @param jobs job的map集合
     */
    private JobRepository(ActorContext<Command> context, Map<Long, Job> jobs) {
        super(context);
        this.jobs = jobs;
    }

    // 接收处理所有可能的传入消息并将状态job保留在actor中
    @Override
    public Receive<Command> createReceive() {
        return newReceiveBuilder()
                .onMessage(AddJob.class, this::addJob)
                .onMessage(GetJobById.class, this::getJobById)
                .onMessage(ClearJobs.class, this::clearJobs)
                .build();
    }

    //消息处理..
     /**
     * 处理AddJob消息， 如果job已经存在job集合中，响应job已经存在
     *
     * @param msg AddJob
     * @return
     */
    private Behavior<Command> addJob(AddJob msg) {
        long jobId = msg.job.id;
        getContext().getLog().info("actor 添加job {}", msg.job.toString());
        if (jobs.containsKey(jobId))
            msg.replyTo.tell(new KO("Job-" + jobId + " 已经存在"));
        else {
            jobs.put(jobId, msg.job);
            msg.replyTo.tell(OK.getInstance());
        }
        return Behaviors.same();
    }

    private Behavior<Command> getJobById(GetJobById msg) {
        getContext().getLog().info("actor 根据id-{}查询job ", msg.id);
        if (jobs.containsKey(msg.id)) {
            msg.replyTo.tell(Optional.of(jobs.get(msg.id)));
        } else {
            msg.replyTo.tell(Optional.empty());
        }
        return Behaviors.same();
    }

    private Behavior<Command> clearJobs(ClearJobs msg) {
        msg.replyTo.tell(OK.getInstance());
        jobs.clear();
        return Behaviors.same();
    }
```

### 6.2.3. 定义Route

定义与先前定义的Actor行为进行通信并处理其所有可能响应的Route.

```java
package com.tcfuture.akka.http.interaction;

//#route

import akka.actor.typed.ActorRef;
import akka.actor.typed.ActorSystem;
import akka.actor.typed.javadsl.AskPattern;
import akka.http.javadsl.marshallers.jackson.Jackson;
import akka.http.javadsl.model.StatusCodes;
import akka.http.javadsl.server.AllDirectives;
import akka.http.javadsl.server.Route;

import java.time.Duration;
import java.util.Optional;
import java.util.concurrent.CompletionStage;

import static akka.http.javadsl.unmarshalling.StringUnmarshallers.LONG;

/**
 * @author liulv
 * @since 1.0.0
 *
 * 定义与先前定义的Actor行为进行通信并处理其所有可能响应的Route.
 */
public class JobRoutes extends AllDirectives {
    private final ActorSystem<?> system;
    private final ActorRef<JobRepository.Command> buildJobRepository;

    public JobRoutes(ActorRef<JobRepository.Command> buildJobRepository, ActorSystem<?> system) {
        this.system = system;
        this.buildJobRepository = buildJobRepository;
    }

    private Route addOrDelete() {
        return concat(
                post(() ->
                        entity(Jackson.unmarshaller(JobRepository.Job.class), job ->
                                onSuccess(add(job), r -> complete("Job added"))
                        )),
                //删除
                delete(() -> onSuccess(deleteAll(), r -> complete("Jobs cleared")))
        );
    }

    /**
     * 根据Job构建AddJob消息请求Ask, Ask响应通过handleKO方法处理后返回
     *
     * @param job Job
     * @return CompletionStage CompletionStage<JobRepository.OK>
     */
    private CompletionStage<JobRepository.OK> add(JobRepository.Job job) {
        return handleKO(AskPattern.ask(
                buildJobRepository,
                replyTo -> new JobRepository.AddJob(job, replyTo),
                Duration.ofSeconds(3),
                system.scheduler()));
    }

    /**
     * 构建ClearJobs消息请求Ask, Ask响应通过handleKO方法处理后返回
     *
     * @return CompletionStage CompletionStage<JobRepository.OK>
     */
    private CompletionStage<JobRepository.OK> deleteAll() {
        return handleKO(AskPattern.ask(
                buildJobRepository,
                JobRepository.ClearJobs::new,
                Duration.ofSeconds(3),
                system.scheduler()));
    }

    /**
     * 构建Ask请求的路由Route
     *
     * @return Route
     */
    public Route jobRoutes() {
        return pathPrefix("jobs", () ->
                concat(
                        pathEnd(this::addOrDelete), //子路由
                        get(() ->     //jobs/long路由
                                path(LONG, jobId ->
                                        onSuccess(getJob(jobId), jobOption -> {
                                            if (jobOption.isPresent()) {
                                                return complete(StatusCodes.OK, jobOption.get(), Jackson.<JobRepository.Job>marshaller());
                                            } else {
                                                return complete(StatusCodes.NOT_FOUND, "job-" + jobId +
                                                        "不存在");
                                            }
                                        })
                                )
                        )
                )
        );
    }

    /**
     * 根据JobId构建Actor Ask的请求
     *
     * @param jobId Job ID
     * @return CompletionStage<Optional<JobRepository.Job>>
     */
    private CompletionStage<Optional<JobRepository.Job>> getJob(Long jobId) {
        return AskPattern.ask(
                buildJobRepository,
                replyTo -> new JobRepository.GetJobById(jobId, replyTo),
                Duration.ofSeconds(3),
                system.scheduler());
    }

    /**
     *  处理Actor Ask请求的响应，异常处理失败原因或返回CompletionStage<JobRepository.OK>
     *
     * @param stage Actor Ask响应 CompletionStage<JobRepository.Response>
     * @return CompletionStage<JobRepository.OK>
     */
    private CompletionStage<JobRepository.OK> handleKO(CompletionStage<JobRepository.Response> stage) {
        return stage.thenApply(response -> {
            if (response instanceof JobRepository.OK) {
                return (JobRepository.OK)response;
            } else if (response instanceof JobRepository.KO) {
                throw new IllegalStateException(((JobRepository.KO) response).reason);
            } else {
                throw new IllegalStateException("Invalid response");
            }
        });
    }
}
```

### 6.2.4. 创建根Actor

我们创建一个actor系统的根行为Behavior用于引导Web服务器并使用它运行。
1. main方法创建了Config作为参数
2. 然后通过ActorSystem.create方法创建ActorSyste
3. 调用create()创建Behavior并创建HttpServer
4. 并将创建的CompletionStage<ServerBinding> 情况发送给自己，如果ServerBinding不为空则发送Started(binding)消息给自己，否则发送StartFailed(failure)给自己。
5. 最终调用starting(false)创建Behavior
  * 接收StartFailed消息则抛出异常-服务器启动失败
  * 接收Started消息则打印服务启动情况，如果参数为wasStopped为true则发送Stop消息给自己，获取Started消息中ServerBinding传递给running方法创建Actor
  * 接收Stop消息，调用starting(true)方法
6. 5步骤调用了running方法停止Actor，接收到Stop消息，则停止Actor并，onSignal(PostStop..即为停止actor后处理，这里解绑ServerBinding

注意：
* 最终创建Actor是通过running方法，中间都是接收消息处理等

```java
package com.tcfuture.akka.http.interaction;

import akka.actor.typed.ActorRef;
import akka.actor.typed.ActorSystem;
import akka.actor.typed.Behavior;
import akka.actor.typed.PostStop;
import akka.actor.typed.javadsl.BehaviorBuilder;
import akka.actor.typed.javadsl.Behaviors;
import akka.http.javadsl.Http;
import akka.http.javadsl.ServerBinding;
import akka.http.javadsl.server.Route;
import com.typesafe.config.Config;
import com.typesafe.config.ConfigFactory;

import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.CompletionStage;

/**
 * 依赖JobRoutes、JobRepository
 *
 * 最后，我们创建一个引导Web服务器并使用它作为actor系统的根行为：Behavior
 *
 * @author liulv
 */
public class JobAppSample {

    interface Message {}

    /**
     * 启动失败消息
     */
    private static final class StartFailed implements Message {
        final Throwable ex;

        public StartFailed(Throwable ex) {
            this.ex = ex;
        }
    }

    /**
     * 已启动
     */
    private static final class Started implements Message {
        final ServerBinding binding;

        public Started(ServerBinding binding) {
            this.binding = binding;
        }
    }

    private static final class Stop implements Message {}

    /**
     * 创建root Actor - ActorSystem
     * 并创建子JobRepository、JobRoutes构建Route
     *
     * @param host http的ip地址
     * @param port http的端口
     * @return Behavior<Message>
     */
    public static Behavior<Message> create(String host, Integer port) {
        return Behaviors.setup(context -> {
            ActorSystem<Void> system = context.getSystem();
            ActorRef<JobRepository.Command> buildJobRepository = context.spawn(JobRepository.create(), "JobRepository");
            Route routes = new JobRoutes(buildJobRepository, context.getSystem()).jobRoutes();

            CompletionStage<ServerBinding> serverBinding =
                    Http.get(system).newServerAt(host, port).bind(routes);

            //修改后，将给定的第一个参数CompletionStage的结果发送给该Actor（“self”）给定的功能。
            context.pipeToSelf(serverBinding, (binding, failure) -> {
                if (binding != null) return new Started(binding);
                else return new StartFailed(failure);
            });

            return starting(true);
        });
    }

    /**
     * 启动Actor方法，接收各种消息并最终调用自己或running方法创建Behavior，其最终都是调用running方法创建
     * Behavior
     *
     * @param wasStopped 是否停止Actor，为true是停止actor暂时无意义，启动就马上停止有什么意义
     * @return Behavior<Message>
     */
    private static Behavior<Message> starting(boolean wasStopped) {
        return Behaviors.setup(context ->
                BehaviorBuilder.<Message>create()
                        .onMessage(StartFailed.class, failed -> {
                            throw new RuntimeException("服务器启动失败", failed.ex);
                        })
                        .onMessage(Started.class, msg -> {
                            context.getLog().info(
                                    "Server online at http://{}:{}",
                                    msg.binding.localAddress().getAddress(),
                                    msg.binding.localAddress().getPort());

                            if (wasStopped) context.getSelf().tell(new Stop());

                            return running(msg.binding);
                        })
                        .onMessage(Stop.class, s -> {
                            //我们收到了停止消息，但尚未完成开始，
                            //我们无法停止，直到开始完成
                            return starting(true);
                        })
                        .build());
    }

    /**
     * 最终创建Behavior Actor
     *
     * @param binding ServerBinding Http服务绑定信息
     * @return Behavior<Message>
     */
    private static Behavior<Message> running(ServerBinding binding) {
        return Behaviors.setup(context ->
                    BehaviorBuilder.<Message>create().onMessage(Stop.class, msg -> {
                    context.getLog().info("Behaviors 停止...");
                    return Behaviors.stopped();
                }).onSignal(PostStop.class, msg -> {
                    context.getLog().info("ServerBinding 解绑...");
                    binding.unbind();
                    return Behaviors.same();
                }).build()
        );
    }

    public static void main(String[] args) {
        Map<String, Object> overrides = new HashMap<>();
        overrides.put("akka.remote.artery.canonical.port", 27703);
        //overrides.put("akka.cluster.roles", Collections.singletonList(role));

        Config config = ConfigFactory.parseMap(overrides)
                .withFallback(ConfigFactory.load("http_test"));


        ActorSystem<Message> system = ActorSystem.create(
                JobAppSample.create("localhost", 8080), "BuildJobsServer", config);
    }
}
```

### 6.2.5. 运行测试


**运行启动**

直接运行根actor类上的main方法即可，运行结果如下图：
![20200915150830](https://liulv.work/images/img/20200915150830.png)


**新增Job测试**

创建Job JSON文件http_job.json, 内容如下
```json
{
  "id": 2,
  "project-name": "测试2",
  "duration": 1
}
```

通过CD命令到json文件目录，然后执行如curl命令
```shell
cd "$(dirname $0)"
curl http://localhost:8080/jobs -X POST -d @http_job.json --header "Content-Type:application/json"
```

执行几个如下图，新增成功

![20200915151330](https://liulv.work/images/img/20200915151330.png)

**通过ID查询Job信息**

直接通过浏览器或者curl命令`curl http://localhost:8080/jobs/2`, 其中的2为jobId根据实际创建的json中id调整，结果出下图：

![20200915151652](https://liulv.work/images/img/20200915151652.png)

**删除Job信息**

调用`curl http://localhost:8080/jobs -X DELETE`

![20200915152121](https://liulv.work/images/img/20200915152121.png)

再次调用通过ID查询Job信息`curl http://localhost:8080/jobs/2`检查，正常情况会提示查询的ID的Job不存在，如下图

![20200915152646](https://liulv.work/images/img/20200915152646.png)

