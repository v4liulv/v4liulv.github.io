---
title: "PowerJob中Akka ask实现"
subtitle: "「AKKA」- 2.6.8"
layout: post
author: "LiuL"
header-style: text
tags:
  - Akka
  - PowerJob-ask实现
---

# Actor ask介绍

与外部的Ackor进行交互，可以使用send发送后不管，前面文章已经介绍send交互方式，send为最常用的交互方式发送后不管，但是这里需要给外部Actor发生一个消息，并要求返回CompletionState[Response]。为此我们使用akka.actor.type.javadsl.askpattern.ask。请求发送一条消息给一个Actor并获得一个CompletionState[Response] 返回。可通过可设置超时时间，如果在如果时间内没有响应则返回的失败CompletionStage。

实例流程图
: ![20200805213553](https://liulv.work/images/img/20200805213553.png)

# 使用场景和缺陷

适用场景
: 从Actor系统外部查询Actor

缺陷和问题
: * 在返回的CompletionStage上的回调很容易意外地关闭和不安全的可变状态，因为这些回调将在不同的线程上执行。
: * 对一个请求只能有一个单一的响应(参见[每个会话child Actor](https://doc.akka.io/docs/akka/current/typed/interaction-patterns.html#per-session-child-actor))。
: * 当请求超时时，接收方并不知道，可能仍然处理它直到完成，甚至在事后开始处理它。

# 使用示例

## 老版本AbstractActor

在创建ActorSystem的类添加根据指定地址构造Actor方法，返回ActorSelection

```java

 public static ActorSystem actorSystem;

 public static void init() {

     Config akkaBasicConfig = ConfigFactory.load("oms-server.akka.conf");
     actorSystem = ActorSystem.create("oms-server", akkaBasicConfig);
 }

 public static ActorSelection getFriendActor(String address) {
        String path = String.format("akka://%s@%s/user/%s", "oms-server", address, "friend_actor");
        return actorSystem.actorSelection(path);
    }
```

获取远程Actor
```java
ActorSelection serverActor = OhMyServer.getFriendActor(serverAddress);
```

Actor ask
```java
Ping ping = new Ping();
ping.setCurrentTime(System.currentTimeMillis());
CompletionStage<Object> askCS = Patterns.ask(serverActor, ping, Duration.ofMillis(1000));
AskResponse response = (AskResponse) askCS.toCompletableFuture().get(1000, TimeUnit.MILLISECONDS);

//downServerCache.remove(serverAddress);
```


## 新版本AbstractBehavior

我们使用akka.actor.type.javadsl.askpattern.ask请求发送一条消息给一个Actor并获得一个CompletionState[Response] 返回。

![20200805213553](https://liulv.work/images/img/20200805213553.png)

```java
public class CookieFabric extends AbstractBehavior<CookieFabric.Command> {

  interface Command {}

  public static class GiveMeCookies implements Command {
    public final int count;
    public final ActorRef<Reply> replyTo;

    public GiveMeCookies(int count, ActorRef<Reply> replyTo) {
      this.count = count;
      this.replyTo = replyTo;
    }
  }

  interface Reply {}

  public static class Cookies implements Reply {
    public final int count;

    public Cookies(int count) {
      this.count = count;
    }
  }

  public static class InvalidRequest implements Reply {
    public final String reason;

    public InvalidRequest(String reason) {
      this.reason = reason;
    }
  }

  public static Behavior<Command> create() {
    return Behaviors.setup(CookieFabric::new);
  }

  private CookieFabric(ActorContext<Command> context) {
    super(context);
  }

  @Override
  public Receive<Command> createReceive() {
    return newReceiveBuilder().onMessage(GiveMeCookies.class, this::onGiveMeCookies).build();
  }

  private Behavior<Command> onGiveMeCookies(GiveMeCookies request) {
    if (request.count >= 5) request.replyTo.tell(new InvalidRequest("Too many cookies."));
    else request.replyTo.tell(new Cookies(request.count));

    return this;
  }
}

  public void askAndPrint(
      ActorSystem<Void> system, ActorRef<CookieFabric.Command> cookieFabric) {
    CompletionStage<CookieFabric.Reply> result =
        AskPattern.ask(
            cookieFabric,
            replyTo -> new CookieFabric.GiveMeCookies(3, replyTo),
            // asking someone requires a timeout and a scheduler, if the timeout hits without
            // response the ask is failed with a TimeoutException
            Duration.ofSeconds(3),
            system.scheduler());

    result.whenComplete(
        (reply, failure) -> {
          if (reply instanceof CookieFabric.Cookies)
            System.out.println("Yay, " + ((CookieFabric.Cookies) reply).count + " cookies!");
          else if (reply instanceof CookieFabric.InvalidRequest)
            System.out.println(
                "No cookies for me. " + ((CookieFabric.InvalidRequest) reply).reason);
          else System.out.println("Boo! didn't get cookies in time. " + failure);
        });
  }
```

注意，验证错误在消息协议中也是显式的。GiveMeCookies请求可以用cookie或InvalidRequest进行响应。请求者必须决定如何处理InvalidRequest应答。有时应该将其视为失败的未来，因此可以将应答映射到请求者端。还请参阅[通用响应包装器](https://doc.akka.io/docs/akka/current/typed/interaction-patterns.html#generic-response-wrapper)，了解成功或错误的响应。

```java
CompletionStage<CookieFabric.Reply> result =
    AskPattern.ask(
        cookieFabric,
        replyTo -> new CookieFabric.GiveMeCookies(3, replyTo),
        Duration.ofSeconds(3),
        system.scheduler());

CompletionStage<CookieFabric.Cookies> cookies =
    result.thenCompose(
        (CookieFabric.Reply reply) -> {
          if (reply instanceof CookieFabric.Cookies) {
            return CompletableFuture.completedFuture((CookieFabric.Cookies) reply);
          } else if (reply instanceof CookieFabric.InvalidRequest) {
            CompletableFuture<CookieFabric.Cookies> failed = new CompletableFuture<>();
            failed.completeExceptionally(
                new IllegalArgumentException(((CookieFabric.InvalidRequest) reply).reason));
            return failed;
          } else {
            throw new IllegalStateException("Unexpected reply: " + reply.getClass());
          }
        });

cookies.whenComplete(
    (cookiesReply, failure) -> {
      if (cookies != null) System.out.println("Yay, " + cookiesReply.count + " cookies!");
      else System.out.println("Boo! didn't get cookies in time. " + failure);
    });
```

有用的时候
: 从Actor系统外部查询Actor

存在问题
: * 在返回的CompletionStage上的回调很容易意外地关闭和不安全的可变状态，因为这些回调将在不同的线程上执行。
: * 对一个请求只能有一个单一的响应(参见[每个会话child Actor](https://doc.akka.io/docs/akka/current/typed/interaction-patterns.html#per-session-child-actor))。
* 当请求超时时，接收方并不知道，可能仍然处理它直到完成，甚至在事后开始处理它。

